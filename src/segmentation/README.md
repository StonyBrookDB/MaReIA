# MaReIA Map Function

This is the documentation of the map function of the MaReIA image analysis framework. The Map function performs segmentation, normalization(boundary fixing) on an input array of an image tile generated from the previous tiling process, and outputs lines where each line contains information on one object.

## Getting Started

The instructions of this section will get you a copy of the map function up and running on your local machine for development and testing purposes.

### Prerequisites

OpenCV library is required for setting up this project. The instruction of installing OpenCV on a Linux machine can be found [HERE](https://docs.opencv.org/3.4/d7/d9f/tutorial_linux_install.html) Please follow the instruction and verify OpenCV is properly installed. After OpenCV is working, you may continue to the next step.

* Please be noted that OpenCV also requires some extra packages on your local machine, such as GCC 4.4.x or later, CMake 2.87 or higher, Git, GTK+2.x or higher, including headers (libgtk2.0-dev), pkg-config, ffmpeg or libav development packages: libavocodec-dev, libavformat-dev, libswscale-dev. More optional packages information are available [HERE](https://docs.opencv.org/3.4/d7/d9f/tutorial_linux_install.html)

### Installing

```
Simply clone the entire directory of "src" to your local machine. 
```
```
cd into the "src" directory on your local machine.
```
```
Open and edit the "Makefile" file in the "src" folder as follows: 
- modify: CMAKE_SOURCE_DIR = <the path to your "src" directory>
- modify: CMAKE_BINARY_DIR = <the path to your "src" directory>
- modify the main all target so that all CMakeFiles will be under your "src" directory
```
```
Issue the command: make
```
```
Check if the executable called "mapperImageSegment" was successfully generated.   
```

### Running the test

```
Run the executable generated in the previous step by issuing the command: ./mapperImageSegment
```
A sample test image tile will be processed by the map function and the output key-value pairs will be in the "output.txt" under "src" directory. 

## API Interface

The map function is located in the mapperImageSegment.cpp file and the signature of the function is:
read_tile(input_arr, segmentation_method, tile_meta_data, normalize_options, output_format)
The function parameter details are as follows:

### input_arr

input_arr is a OpenCV Mat type array. It is the image tile raster data, generated by the "getRasterData" function which is also located in the mapperImageSegement.cpp file.

### segementation_method

This is the name of the method that is used to create the image mask from input_arr. By default, the watershed thresholding method is used. Our framework is extensible to any segmentation algorithm that a user is willing to use to generate the image mask. However, developers should be advised that the implementation of a segmentation method should take a OpenCV Mat array and output a image mask in OpenCV Mat array as well.

### tile_meta_data

This is a struct that contains the meta data information of a image tile. The information include tile ID, tile X coordinate, tile Y coordinate, tile width, tile height, and tile buffer size. The struct is defined in the mapperImageSegment.cpp.

### normalize_options

This is to encode the scheme of what level of normalization should be used. There are 3 normalization options. Option 0 means no normalization for the raw contours. Option 1 will make valid polygons based on the raw contours. Option 2 will further fix self-intersect polygons. Option 2 is recommended. 

The normalization and boundary fixing is done by using a library previously developed. The boundary fixing functions can be found under directory /src/PAISBoundaryFixer.

### output_format

This specifies the format of the output. By default, well know text (WKT) is used. The output key-value are separated by tabs. The key is the image_name-tile_id, and the value includes object_id, object_geometry, and object_type. There are two types of object type denoted by "non-boundary polygon" which means the polygon is entirely included in the core zone, and by "boundary polygon" which means that the polygon is on the boundary of the core zone. 

An example line of the output would look like this: 
CGA-12-0618-01Z-00-DX1.svs_28672_16384.pnm	413;	 31464,19960 31474,19958 31463,19955 31462,19955 31460,19957 31464,19960	non-boundary polygon
Where "CGA-12-0618-01Z-00-DX1.svs_28672_16384.pnm" is the key, followed by a tab. "413;" is the object_id, followed by a tab. " 31464,19960 31474,19958 31463,19955 31462,19955 31460,19957 31464,19960" is the object_geometry, led by a space and followed by a tab. The points of the object_geometry are separated by spaces, and the x and y coordinates are separated by a comma. "non-boundary polygon" is the object_type.

## Deployment

Here are some additional notes for developers about how to deploy and test the map function.

### About the tile meta data

Please refer to the main function of the mapperImageSegment.cpp file where the tile meta data are generated. The attributes of the meta data can be modified there.

### To test your own image tiles

Simply put your own tile image under the "src" directory. In the main function of the mapperImageSegment.cpp file, there is a string array called "images". Add the path of your own image tile to that array. Please be advised that you also need to modify the indexes of the arrays in the "getRasterData" and the "read_tile" function calls below accordingly.

### To implement your own segmentation method

By default, the watershed thresholding method is used to generated the tile image raster data. However, our image analysis framework is extensible to any segmentation algorithm. Developers are welcome to implement and use their own image segmentation method to create the image mask in the map function. The segmentation method should take a OpenCV Mat array and output a image mask in OpenCV Mat array as well. In the read_tile map function, the input Mat variable is called "inputImg" and the output Mat variable is called "outImg". The customized segmentation method can be easily added to the map function in a way that is similar to how we implemented the watershed thresholding method. Please refer to how the watershed method is used in the mapperImageSegment.cpp for details.

## Acknowledgments

* Fusheng Wang, Associate Professor, Department of Biomedical Informatics, Department of Computer Science, Stony Brook University, Stony Brook, NY 11790
* Hoang Vo, PHD Student, Department of Computer Science, Stony Brook University, Stony Brook, NY 11790